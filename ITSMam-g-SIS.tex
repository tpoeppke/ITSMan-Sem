\documentclass{semdoc}
\usepackage{enumitem}
\usepackage{amsfonts}
\usepackage{ngerman}
% Template: $Id: t01_txt.tex,v 1.7 2000/05/23 12:13:37 bless Exp $
% -----------------------------------------------------------------------------
% Seminarbeitrag
% -----------------------------------------------------------------------------
% Kommentare beginnen mit einem %-Zeichen

\docbegin

%
% --> Oberhalb der Linie bitte nichts ändern.
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% Stellen, an denen etwas geaendert werden soll, sind wie hier gekennzeichnet.
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 

%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> Bitte den Titel des Beitrages in die nächste Zeile eintragen:
\title{IT-Sicherheitsmanagement Seminar: Group-Centric Models for Secure Information Sharing (g-SIS)}
\newtheorem{definition} {Definition}
\newtheorem{trace} {Anforderung}
\newtheorem{bsp} {Beispiel}
% --> ... und den Namen des Autors:
\author{Uwe Kühn, Tobias Pöppke}
% --> optional eine URL mailto:... oder http://www...
%\authorURL{mailto:tobias.poeppke@student.kit.edu}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
%
%
\maketitle
%
% -----------------------------------------------------------------------------
% ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG
% -----------------------------------------------------------------------------
% --> Im Text sollte \section der "höchste" Gliederungsbefehl sein,
%     also bitte kein \chapter oder gar \part verwenden.
%     Der Text kann aber mit \section{}, \subsection{}, \subsubsection{}
%     untergliedert werden.
%
%     Bitte nicht die Befehle \input oder \include verwenden, also den
%     Text _nicht_ in mehrere Dateien aufteilen! 
%
%     \newpage oder manuelle Zeilenumbrüche (\\) sollten ebenfalls nicht 
%     verwendet werden.
%
%     Bitte darauf achten, dass im _Quelltext_ ein Abschnitt nicht nur 
%     in einer Zeile steht (das macht z.B. Word beim Exportieren ohne
%     Zeilenumbruch), der Abschnitt sollte auch bei 80 Zeichen pro Zeile
%     noch lesbar sein, d.h. Zeilenumbrüche im Quelltext bitte entsprechend
%     einfügen.
%
%     Referenzen auf andere Abschnitte sind bitte mit \ref{...}, wie 
%     anschliessend gezeigt, anzugeben und nicht etwa als Text wie
%     "siehe auch Abschnitt 2.2"
%
%     Anführungszeichen sind nicht einfach so "Text" einzugeben, sondern so:
%     "`Text"', andernfalls gibt es Fehler.
%
%     Das Zeichen ~ erzeugt einen Leerraum an dem aber nicht getrennt wird.
%     Weitere Trennstellen:
%     "- = zusätzliche Trennstelle
%     "| = Vermeidung von Ligaturen und mögliche Trennung (bsp: Schaf"|fell)
%     "~ = Bindestrich an dem keine Trennung erlaubt ist (bsp: bergauf und "~ab)
%     "= = Bindestrich bei dem Worte vor und dahinter getrennt werden dürfen
%     "" = Trennstelle ohne Erzeugung eines Trennstrichs (bsp: und/""oder)
%
%     Weiterer Hinweis: 
%     KEIN Glossar erstellen! Abkürzungen sind im Text zu erklären!
%     Der Text ist mit z.B. mit ispell auf Schreibfehler zu prüfen 
%     (am besten aus dem Emacs heraus, 
%     Menü: Edit -> Spell -> Select Deutsch8, dann Edit -> Spell -> Check Buffer)
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> ... und hier kommt der Text: 
\section{Einleitung} % in die Klammern die Ueberschrift 
 \label{Introduction} % und ein Label
 
 Durch die stetige Zunahme des Informations- und Kommunikationshungers der Gesellschaft ist auch der Bedarf an sicheren Kommunikationskanälen gewachsen. 
 Denn auch wenn ein Großteil der im Internet verfügbaren Information jedem zugänglich sein soll, 
 gibt es doch immer wieder auch Information die nur für den Zugriff durch einen bestimmten Personenkreis über das Netzwerk bestimmt ist. 
 Doch die Sicherheit im Hinblick auf den Zugang zu diesen Informationen erstreckt sich nicht nur auf den Zugangskanal, 
 sondern auch über das damit in Verbindung stehende Berechtigungssystem. So muss für viele aktuelle Anwendungen die auf verteilten Informationen 
 aufbauen nicht nur ein einfacher und sicherer Zugang zu diesen Informationen ermöglicht werden, sondern es müssen auch unterschiedliche Berechtigungen 
 für unterschiedliche Nutzer ermöglicht werden. Weiterhin sollen verschiedene Benutzer zu Gruppen zusammengefasst werden können. 
 Ähnlich wie Benutzer sollen sich auch mehrere Informationen zu einer Informationsgruppe verknüpfen lassen, für die dann einheitliche Zugriffsrichtlinien 
 definiert werden können. In der Vergangenheit sind hierzu eine Vielzahl von Systemen entwickelt worden, die sich mit diesen Problemstellungen beschäftigen. 
 Bei einigen Anwendungsszenarien stoßen diese Systeme jedoch an Ihre Grenzen. So fehlt letztlich ich allen verbreiteten Systemen der Zeitbezug. 
 Doch gerade der ist sehr wichtig für viele aktuelle Anwendungsfälle, wie z.B. Aboservices für IT-Produkte wie Online Video und Musik-Plattformen 
 mit bezahltem Content und zeitlich beschränkter Nutzung. In dieser Arbeit werden in Kapitel 2 zuerst einige weit verbreiteten Zugriffsmechanismen untersucht, 
 dann die Grenzen dieser Systeme vor allem in Bezug auf aktuelle Anwendungsszenarien aufgezeigt und dann mit Kapitel 3 ein neues System vorgestellt, 
 welches die Beschränkungen der herkömmlichen Systeme aufzuheben versucht. Es handelt sich dabei um das Group-Centric Secure Information Sharing (g-SIS) Modell, 
 und wurde von Krishnan et al. \cite{gsis1} sowie von Sandhu et al. \cite{gsis2} beschrieben. In Kapitel 4 schließlich gezeigt, 
 dass sich die bereits vorhandenen Modelle mittels g-SIS darstellen lassen, woran zuletzt Fazit und Ausblick der Arbeit in Kapitel 5 anknüpfen.
 
 
% % Das Label ist eine Marke, auf die man später mit \ref{labelname} verweisen kann.
% % BITTE ALLE LABELS MIT t01_ BEGINNEN.
% % Hier den Text eintragen:
% Ich bin der Beispieltext und habe eine Referenz auf Abschnitt~\ref{tmp_Introduction}. 
% Verschiedene Schriftgrößen wie {\small small}, {\footnotesize footnotesize} und
% Stile \emph{hervorgehobener Text}, \textit{kursiv}, \textsl{schräggestellt} (anders
% als kursiv), \textbf{Fettdruck} (sollte \emph{nicht} verwendet werden).
% Text in Anführungszeichen sieht so aus: "`korrekt"'.

% Und nun ein Bild:
% % Hinweis: der Text in der Abbildung sollte nicht größer als die
% % Schriftgröße des Fließtextes (11pt) sein und möglichst mit 
% % serifenlosen Font (Helvetica, Arial).
% %
% \begin{figure}[htb] 
	% \centerline{\includegraphics*[width=0.8\textwidth]{an_example_picture}}
% \caption{Dies ist die Bildunterschrift} 
% \label{tmp_Bild1}
% \end{figure}

% Umlaute gibt es auch: ä, ö, ü, Ä, Ö, Ü, ß. Alternativ kann man notfalls 
% auch "a, "o, "o, "A, "O, "U, "s eingeben. Die Umlaute werden nach ISO 8859-1
% codiert. Eingabemöglichkeiten im \texttt{emacs} wie folgt:
% \begin{enumerate}
% \item
% Wenn keine Umlaute auf der Tastatur vorhanden sind, kann man 
% z.B. mit folgender Tastenkombination (Tasten nacheinander drücken)
% ein ä erzeugen: \fbox{\parbox{1.05cm}{\tiny compose\\ character}}
% dann \fbox{\"{}} dann \fbox{a}.
% % Im Klartext: [compose character] ["] [a]
% \item
% Einfacher geht's jedoch mit dem \emph{iso-accents-mode} des
% \texttt{emacs}: Einfach \fbox{\"{}} gefolgt von \fbox{a}
% drücken.
% % Im Klartext: ["] [a]
% \end{enumerate}

% % beachte Anweisungen am Ende des Dokumentes, wenn Literatur referenziert
% % werden soll
% Nun einen Verweis auf eine Literaturstelle: \cite{t01_buch1}.
% Die Literatur ist in der BIB\TeX-Datei einzugeben (Endung \texttt{.bib}).
% Es wird letztlich nur die Literatur aus der Datei aufgeführt, die auch im Text referenziert wurde. Möchte man dies ändern, so muss die unten stehende Zeile '\verb|%\nocite{*}|' auskommentiert werden. Der Editor
% \texttt{emacs} unterstützt die Eingabe im BIB\TeX-Format (nach
% Laden einer Datei mit Endung \texttt{.bib}).


% Als nächstes präsentieren wir eine Aufzählung:
% \begin{itemize}
% \item Punkt1\\
      % Eine Formel (nicht numeriert): 
      % \[ \frac{1}{n} \cdot \sum_{i=1}^{n}{(\overline{x}-x_i)^2} \]
% \item Punkt2
% \item Punkt3
% \end{itemize}

% Man kann übrigens auch Bilder referenzieren: Bild~\ref{tmp_Bild1} oder
% Unterabschnitte wie z.B. den nächsten Unterabschnitt~\ref{tmp_Subsection}.
% URLs lassen sich so angeben: \urltext{http://www.uni-karlsruhe.de/} oder
% explizit \href{http://www.uni-karlsruhe.de/}{Universität Karlsruhe (TH)}
% (dann erscheint die URL nicht als zwangsweise im Text).

\section{Grundlagen}
\label{basics}

Hier sind alle zum Verständnis der im weiteren behandelten Fragestellungen nötigen Voraussetzungen, Definitionen und Vereinbarungen aufgeführt.
Grundsätzlich muss bei der Unterscheidung von Zugriffskontrollmodellen zwischen Policy und Enforcement Ebene unterschieden werden. 
Diese Unterscheidung basiert auf dem Prinzip der Trennung von Policy und Mechanism, die von Levin et al. eingeführt wurde \cite{policy}.
Dabei wird unterschieden zwischen der Definition einer Policy und deren konkreter Umsetzung in einem System.
Die Policy Ebene beschäftigt sich daher nicht mit den Problemen, die bei der Umsetzung entstehen, 
wie zum Beispiel die verwendeten kryptographischen Bausteine, die eingesetzten Datenspeicher oder Quality-of-Service Überlegungen.
Diese Dinge werden in der Enforcement Ebene berücksichtigt und unter den resultierenden Bedingungen versucht, 
das Modell der Policy Ebene möglichst genau nachzubilden. Im folgenden werden daher hauptsächlich die Policy Aspekte von g-SIS 
und den zugrunde liegenden Ideen betrachtet.

\subsection{Lattice-Based Access Control}
\label{lbac}
Eine wichtige Klasse von Zugriffskontrollmodellen sind \emph{Lattice-Based Access Control (LBAC)} Modelle.
Die Grundlagen von LBAC wurden in den 1970ern von Bell, LaPadula, Biba und Denning gelegt und entstanden 
aus den Bedürfnissen des Verteidigungssektors. Eine Übersicht über die verschiedenen Modelle 
und formale Definitionen, sowie weiterführende Referenzen finden sich bei Sandhu \cite{lbac2}.

LBAC Modelle konzentrieren sich auf die Betrachtung des Informationsflusses zwischen Sicherheitsklassen eines Systems.
Dazu wird jedem \emph{Objekt} des Systems eine \emph{Sicherheitsklasse} zugewiesen. 
Ein \emph{Objekt} sei hier informell definiert als ein Container für Informationen.
Wenn nun die Informationen eines Objekts \emph{x} zu einem Objekt \emph{y} fließen geht 
damit ein \emph{Informationsfluss} einher. Dieser Informationsfluss findet zwischen den 
Sicherheitsklassen der jeweiligen Objekte statt.

Die \emph{Richtlinien} mit denen die zulässigen Informationsflüsse beschrieben werden, können mithilfe von \emph{Lattices} beschrieben werden.
Ein \emph{Lattice} ist in diesem Zusammenhang eine partiell geordnete Menge der Sicherheitsklassen. 
Jedem Objekt wird dann eine Sicherheitsklasse zugewiesen. Im Modell von Bell und LaPadula gelten beispielsweise die folgenden Aussagen.
Benutzer können \emph{Subjekte}, wie zum Beispiel einen Prozess, erstellen, die eine Sicherheitsklasse besitzen, 
die von der Sicherheitsklasse des Benutzers im Lattice dominiert wird. 
Ein Subjekt kann genau dann Objekte lesen, wenn die Sicherheitsklasse des Objekts von der des Subjekts dominiert wird.
Auf ein Objekt schreibend zugreifen kann ein Subjekt genau dann, wenn die Sicherheitsklasse des Objekts die Sicherheitsklasse des Subjekts dominiert.

\subsection{Domain and Type Enforcement}
\label{dte}
Die Idee des \emph{Domain and Type Enforcement (DTE)}, von Badger et al. vorgeschlagen \cite{dte}, ist eine Erweiterung der Lattice-Based Access Control Modelle um \emph{Domänen} und \emph{Typen}.
Eine \emph{Domäne} ist äquivalent zur Sicherheitsklasse eines Subjekts in LBAC und die Sicherheitsklasse eines Objektes in LBAC wird als \emph{Typ} definiert. 
Subjekte werden daher in Domänen eingeteilt und Objekte in Typen. Um nun den Informationsfluss zu kontrollieren, wird eine Matrix benutzt, 
in der die Lese- und Schreibrechte für jede Kombination von Domäne und Typ festgelegt werden.
Diese Art der Zugriffskontrolle ist beispielsweise dann anwendbar, 
wenn es gewünscht ist, vertrauenswürdige Pipelines zu etablieren. 
Wenn es zum Beispiel nötig ist, dass Informationen nur über ein Subjekt einer 
dritten Domäne zum Zielobjekt fließen dürfen, ist dies mit klassischen LBAC-Modellen nicht möglich.
Dies liegt an der transitiven Natur der zugrunde liegenden Relation in LBAC. 

Da die im Lattice höher angesiedelten Sicherheitsklassen in LBAC alle unter ihnen 
liegenden Sicherheitsklassen dominieren und diese Relation transitiv ist, kann Information immer 
von allen dominierten Sicherheitsklassen direkt in die dominierende Sicherheitsklasse fließen.
Da bei DTE eine Matrix den zulässigen Informationsfluss definiert, 
ist diese Relation nicht länger transitiv und die Informationen können nach Wunsch über verschiedene Wege geleitet werden.

\subsection{Role-Based Access Control}
\label{rbac}
\emph{Role-Based Access Control (RBAC)} ist ein Zugriffskontrollmodel, dass von Sandhu et al. und Ferraiolo et al. vorgeschlagen wurde \cite{sandhu96, ferraiolo2001proposed}.
Ein Benutzer sei im Folgenden, ohne Beschränkung der Allgemeinheit, definiert als ein menschlicher Benutzer.
Das Hauptmerkmal von RBAC sind \emph{Rollen}. Eine Rolle basiert auf der Idee, eine Position innerhalb einer Organisation darzustellen, 
die mit bestimmten Rechten und Verantwortlichkeiten einhergeht. 
Daher werden jeder Rolle bestimmte \emph{Zugriffsrechte} auf \emph{Objekte} zugewiesen, wobei ein \emph{Objekt} Informationen bereitstellen oder erhalten kann.
Ein \emph{Zugriffsrecht} gewährt einer Rolle die Möglichkeit eine oder mehrere \emph{Operationen} auf einem oder mehreren Objekten auszuführen.

Ein Benutzer kann in RBAC mehreren Rollen zugehören und eine Rolle kann ebenfalls mehreren Benutzern zugeordnet sein.
Diese Relation wird als \emph{User Assignment (UA)} bezeichnet. 
Genau so können auch mehrere Zugriffsrechte zu mehreren Rollen und umgekehrt, zugewiesen werden. 
Diese Relation wir als \emph{Permission Assignment (PA)} bezeichnet.

Ein weiteres Konzept das in RBAC benutzt wird, sind \emph{Sessions}. 
Ein Benutzer kann einer oder mehreren Sessions zugeordnet sein und jede Session ist genau einem Benutzer zugeordnet.
In jeder Session kann wiederum eine Untermenge der Rollen, denen der Benutzer angehört, aktiv sein.
Welche Rollen, und damit auch welche Zugriffsrechte, in einer Session aktiv sind, kann durch die Funktion \emph{session\_roles} abgefragt werden.
Um zu erfahren, welche Sessions zu einem Benutzer gehören, kann die Funktion \emph{user\_sessions} aufgerufen werden.

Die obigen Eigenschaften beschreiben \emph{Core RBAC} beziehungsweise \emph{RBAC$_0$}. Formal kann damit Core RBAC wie folgt definiert werden.
\begin{definition} [Core RBAC] \ \\
\begin{itemize}
\item \emph{USERS, ROLES, OPS und OBS}: Mengen der Benutzer, Rollen, Operationen und Objekte.
\item \emph{$UA \subseteq USERS \times ROLES$}: Menge der Zuweisungen von Benutzern zu Rollen.
\item \emph{$assigned\_users: (r: ROLES) \rightarrow 2^{USERS}, assigned\_users(r) = \{u \in USERS | (u, r) \in UA\}$}: Zuordnung der Rolle \emph{r} zu der zugehörigen Menge der Benutzer.
\item \emph{$PRMS = 2 ^ {(OPS \times OBS)}$}: Menge der Zugriffsrechte.
\item \emph{$PA \subseteq PRMS \times ROLES$}: Zuordnung der Zugriffsrechte zu Rollen.
\item \emph{$assigned\_permissions(r: ROLES) \rightarrow 2^{PRMS}, assigned\_permissions(r) = \{u \in USERS | (u, r) \in PA\}$}: Zuordnung der Rolle \emph{r} zu der zugehörigen Menge der Zugriffsrechte.
\item \emph{$Ob(p: PRMS) \rightarrow \{op \subseteq OBS\}$}: Gibt die Menge der Operationen an, die einem Zugriffsrecht \emph{p} zugeordnet sind.
\item \emph{$Ob(p: PRMS) \rightarrow \{ob \subseteq OBS\}$}: Gibt die Menge der Objekte an, die einem Zugriffsrecht \emph{p} zugeordnet sind.
\item \emph{SESSIONS}: Menge der Sessions.
\item \emph{$user\_sessions(u: Users) \rightarrow 2^{SESSIONS}$}: Zuordnung eines Benutzers \emph{u} zu einer Menge von Sessions.
\item \emph{$session\_roles(s: SESSIONS) \rightarrow 2^{ROLES}, session\_roles(s_i) \subseteq \{r \in ROLES | (session\_users(s_i), r) \in UA\}$}: Zuordnung einer Session \emph{s} zu der zugehörigen Menge von Rollen.
\item \emph{$avail\_session\_perms(s: SESSIONS) \rightarrow 2^{PRMS}, \bigcup{r \in session\_roles(s)}{assigned\_permissions(r)}$}: Die Zugriffsrechte, die einem Benutzer in einer Session zur Verfügung stehen.
\end{itemize}
\end{definition}

Das Core RBAC Modell definiert die grundlegenden Eigenschaften jedes RBAC Modells. 
Es wurden auch weitergehende Modelle beschrieben, wie hierarchisches RBAC und 
constrained RBAC. Für die Definitionen dieser Modelle sei an dieser Stelle jedoch lediglich auf Ferraiolo et al. \cite{ferraiolo2001proposed} verwiesen

\subsection{Linear Temporal Logic}
\label{ltl}

Wie auch die meisten anderen Zugriffsmechanismen bedient sich auch g-SIS zur grundlegenden Definition seiner Eigenschaften der Aussagenlogik. 
Um den zusätzlichen zeitlichen Aspekt zu berücksichtigen ist jedoch eine spezielle Form der Aussagenlogik nötig, die lineare temporale Logik. 
Im weiteren Verlauf wird diese LTL bezeichnet. Die Notationen für die herkömmlichen aussagenlogischen Verknüpfungen wie {$UND$} und {$ODER$} Operatoren, 
etc. werden als bekannt vorausgesetzt. Andere Operatoren sind jedoch etwas spezieller und werden im Zusammenhang mit g-SIS häufig benutzt und hier deswegen 
explizit erklärt. Die Operatoren lassen sich hierbei grob nach zwei Merkmalen kategorisieren. Das erste Merkmal ist dabei die Anzahl der Operanden, 
hiernach kann man in unäre und binäre Operatoren unterteilen. Das zweite Merkmal ist der Zeitbezug, 
wonach sich mit LTL Aussagen in zunkunftsbezogene und Vergangenheitsbezogene Aussagen unterteilen lassen.


\subsection{LTL -Operatoren}
\subsubsection{Unär/Vergangenheitsbezogen}

 \emph{$\Theta\,p$}: die Aussage {$p$} ist bisher immer gültig 
gewesen

\emph{$\diamondsuit\,p$}: die Aussage {$p$} ist bisher mindestens einmal gültig
gewesen

\subsubsection{Unär/Zukunftsbezogen}

 \emph{$\circ\,p$}: die Aussage {$p$} wird im nächsten Zustand 
gültig sein

\emph{$\Box\,p$}: die Aussage {$p$} wird immer gültig sein



\subsubsection{Binär/Vergangenheitsbezogen}
{$p\,\mathcal{S}\,q$}: seit Auftreten von {$q$} ist 
auch {$p$} gültig

\subsubsection{Binär/Zukunftsbezogen}
{$p\,\mathcal{U}\,q$}: bis zum Auftreten von {$q$} 
wird {$p$} mindestens gültig sein


{$p\,\mathcal{W}\,q$}: bis zum Auftreten von {$q$} ist 
{$p$} mindestens gültig, falls {$q$} nie auftritt 
wird {$p$} immer gültig sein

\subsection{Beispiel}

Um die Anwendung von LTL etwas zu verdeutlichen, hier ein Beispiel, wie sich Aussagen mit einem Zeitbezug mittels LTL formalisieren  lassen.

\begin{bsp} [Aussage in LTL]
\hfil\\
{$ \phi = \Box(Authz \rightarrow (Authz\, \mathcal{W}\, (Join \vee    Leave \vee  Add    \vee Remove)))$}
\end{bsp}

Es gilt immer ({$\Box$}), dass eine Autorisierung ({$Authz$}) die fortwährende  Autorisierung impliziert({$\rightarrow Authz$}), mindestens solange bis ({$\mathcal{W}$}) entweder ein {$Join$}, {$ Leave$}, {$Add$} oder {$Remove$}  auftritt.


\subsection{Mengen, Symbole}

\subsubsection{Symbole}
\label{sbl}

Hier ein kurzer Überblick über die Objekte oder Mengen, die g-SIS in seiner Spezifikation behandelt und die dafür verwendeten Symbole und Eigenschaften.

{$USERS$}: Die unabgeschlossene Menge aller Nutzer. Hierbei kann es sich z.B. um Rechner oder Menschen handeln.

{$OBS$}: Die unabgeschlossene Menge alle Objekte. Z. B. Dateien oder Ressourcen wie Drucker, Schnittstellen, etc.

{$OPS$}: Die abgeschlossene Menge aller Operationen. Der Einfachheit halber betrachten wir im Folgenden nur read und write Operationen, es ließen sich hier jedoch beliebig viele weitere Operationen definieren, 
etwa das Anlegen von neuen Objekten, oder das Löschen von Objekten. 

{$AUTH$}: Die abgeschlossene Menge der Autorisationsstufen. Der Einfachheit halber wird hier nur ein binärer Autorisierungsmechanismus betrachtet.


\subsubsection{Abgeleitete Mengen} 

\begin{itemize}
\item \emph{$Berechtigungsr$}ä{$ume(Gruppe): BR \subseteq {USERS \times OPS \times OBS}$}: Zusammenfassung von Nutzern, Operationen und Objekten zu einem Berechtigungsraum
\item \emph{$Zugriffsberechtigungen: AR \subseteq AUTH \times BR$}: Authentifizierunslevel  eines Raumes
\end{itemize}


\section{G-SIS}
\label{gsis}

\subsection{Grundfunktionalität} 
Die Grundfunktionalität des g-SIS Modells lässt sich sehr gut metaphorisch veranschaulichen. Man könnte es als ein System von Meetingräumen betrachten. Nutzer können einen Raum sowohl betreten als auch verlassen. 
Genauso können Objekte in den Raum eingebracht werden, oder aus dem Raum herausgenommen. Alle Nutzer im Raum können auf die im Raum vorhandenen Objekte zugreifen (z.B. das Licht einschalten). 
Die Berechtigung zur Ressourcennutzung ist somit nicht an Nutzer oder Objekte gebunden, sondern an den Raum.
Um diese Operationen im Modell abzubilden werden die folgenden Funktionen definiert. 
\begin{itemize}
\item \emph{$Join(u,r): USERS \times BR \rightarrow BR$}: Hinzufügen eines Benutzers zu einem Berechtigungsraum
\item \emph{$Add(o,r): OBS \times BR \rightarrow BR$}: Hinzufügen eines Objekts zu einem Berechtigungsraum
\item \emph{$Leave(u,r): USERS \times BR \rightarrow BR$}: Entfernen eines Benutzers aus einem Berechtigungsraum
\item \emph{$Remove(o,r): OBS \times BR \rightarrow BR$}: Entfernen eines Objekts aus einem Berechtigungsraum
\item \emph{$Authz(a,r): AUTH \times BR \rightarrow AR$}: Setzen des Berechtigungslevels für einen Berechtigungsraum
\end{itemize}


\subsection{Grundlegende Korrektheitsanforderungen}
\label{kor}

Eine g-SIS Spezifikation muss mehrere 
Anforderungen an syntaktische Korrektheit 
erfüllen und zusätzliche Anforderungen an die 
semantische Korrektheit. Alle Anforderungen zusammen bilden die so genannten Core Properties der g-SIS Spezifikation. Darunter ist das kleinstmögliche Regelwerk zu verstehen, mittels dem sich g-SIS spezifizieren lässt.

\subsubsection{Anforderungen an die Syntaktische Korrektheit}
\label{kor1}

\begin{trace}[Keine Operationsüberlagerung]
Add und Remove können nicht gleichzeitig auftreten für ein Objekt, ebenso wenig wie Join und Leave für einen Nutzer gleichzeitig auftreten dürfen
\end{trace}
\begin{trace}[Keine Mehrfachmitgliedschaften]
Objekte und Nutzer können nicht mehrfach einer Gruppe hinzugefügt oder entfernt werden
\end{trace}
\begin{trace}[Sequenzielle Operationen]
Immer nur eine Operation zu einem gegebenen Zeitpunkt pro Nutzer oder Objekt
\end{trace}
\begin{trace}[Positive Definitheit]
Kein Leave oder Remove ohne vorheriges Join oder Add
\end{trace}

\subsubsection{Anforderungen an die Semantische Korrektheit}
\label{kor2}
\begin{trace}[Persistenz]
 Autorisierung eines Nutzers für ein Objekt bleibt mindestens erhalten (Authorization Persistence) bis eine Funktion auf die Gruppe angewendet wird. Das gilt analog für eine Nichtautorisierung (Revocation Persistence).
\end{trace}
\begin{trace}[Provenienz]
 Ein Nutzer wird erst dann für den Zugriff auf ein Objekt autorisiert, wenn er erstmalig mit dem Objekt in ein und derselben Gruppe Mitglied ist (Provenienz).
\end{trace}
\begin{trace}[Begrenztheit]
Es können keine Autorisierungen eines Nutzers für Objekte einer Gruppe erlangt werden, die während Nicht-Mitgliedschaft dieses Nutzers zur Gruppe hinzugefügt werden (Bounded Authorization).
\end{trace}
\begin{trace}[Verfügbarkeit]
 Objekte sind den Nutzern, die vor dem Objekt der Gruppe hinzugefügt wurden zugänglich(Availability).
\end{trace}
\subsection{Gestaltungsmöglichkeiten für Gruppeneigenschaften}
\label{greig}

Sämtliche hier aufgeführten Vorschläge sind als solche aufzufassen. Sie sind keine Core Properties einer g-SIS Spezifikation. Sie gehen über eine solche hinaus und sollen lediglich zur Veranschaulichung der Flexibilität und Feingranularität d
er Autorisierungsmöglichkeiten dienen.
Hier sind vor allem zwei grundlegende Möglichkeiten (strict und liberal) der funktionalen Ausgestaltung  zu unterscheiden.  Die Operationen unterscheiden sich durch die beiden Ansätze maßgeblich in ihren zeitbezogenen Implikationen.
Hier seien folgende Vorschläge genannt:

\begin{itemize}
\item \emph{Stric Join}: Ein Benutzer kann auf keine Objekte zugreifen, die vor ihm zur Gruppe hinzugefügt wurden.
\item \emph{Liberal Join}: Ein Benutzer kann auf Objekte zugreifen, die vor ihm zur Gruppe hinzugefügt wurden.
\item \emph{Strict Leave}: Kein Benutzer kann auf Objekte der Gruppe mehr zugreifen, nachdem er eine Gruppe verlassen hat.
\item \emph{Liberal Leave }: Ein Benutzer kann nachdem er eine Gruppe verlassen hat weiterhin auf Objekte der Gruppe zugreifen.

\item \emph{Stric Add}: Der Zugriff auf ein Objekt ist nur den Nutzern gestattet, die vor dem Objekt der Gruppe hinzugefügt wurden.
\item \emph{Liberal Add}: Alle Nutzer einer Gruppe können auf ein Objekt zugreifen, wenn es der Gruppe hinzugefügt wird.
\item \emph{Strict Remove}: Wird ein Objekt aus einer Gruppe entfernt, so kann kein Benutzer dieser Gruppe weiterhin auf das Objekt zugreifen.
\item \emph{Liberal Remove}: Wird ein Objekt aus einer Gruppe entfernt, so können die Benutzer dieser Gruppe weiterhin auf das Objekt zugreifen.
\end{itemize}

Möchte man das Ganze noch weiterführen, so kann man auch noch den Wiedereintritt und die damit verbundenen Berechtigungsszenarien betrachten. 
Dies wird hier jedoch nicht mehr betrachtet, es sei jedoch diesbezüglich auf Krishnan et al. \cite{gsis1} verwiesen.

\subsection{Klassifizierung von g-SIS Modellen}
In vielen Fällen ist es notwendig, die Benutzer eines abzusichernden Systems in mehr als eine Gruppe einzuteilen. 
Diese Gruppen können sowohl nach der Art der Relationen zwischen den einzelnen Gruppen unterschieden werden,
als auch nach der Art der Beziehungen zwischen den Benutzern innerhalb einer Gruppe.

Verschiedene Gruppen in g-SIS können \emph{verbunden} oder \emph{isoliert} sein.
Sind Gruppen untereinander \emph{isoliert}, hat die Mitgliedschaft eines Benutzers, 
Subjekts oder Objekts keinen Einfluss auf die Mitgliedschaft eines Benutzers, 
Subjekts oder Objekts in einer anderen Gruppe.

Im Falle mehrerer \emph{verbundener} Gruppen kann die Mitgliedschaft in einer Gruppe 
verschiedene Auswirkungen auf die Mitgliedschaft und die möglichen Operationen in einer anderen Gruppe haben.

Die Mitglieder innerhalb einer Gruppe können wiederum alle die gleichen Zugriffsrechte besitzen.
Diese Art der Gruppe wird in g-SIS definiert als eine \emph{undifferenzierte} Gruppe.
Im Gegensatz dazu können in einer \emph{differenzierten} Gruppe verschiedenen Benutzern 
auch verschiedene Zugriffsrechte eingeräumt werden.

Die genannten Unterschiede und ihre Kombinationen führen zu vier möglichen g-SIS Modellen.
Diese sind das \emph{isoliert undifferenzierte Modell}, das \emph{isoliert differenzierte Modell}, das \emph{verbunden undifferenzierte Modell} 
sowie das \emph{verbunden differenzierte Modell}.

Das \emph{isoliert undifferenzierte Modell} beschreibt das Modell, 
in dem die Mitgliedschaft in einer Gruppe keinen Einfluss auf andere Gruppen im System hat.
Ebenso gibt es innerhalb der einzelnen Gruppen keinen Unterschied in den Zugriffsrechten der einzelnen Mitglieder,
außer den Unterschieden, die durch die g-SIS Core Properties (s.h. Abschnitt \ref{kor}) 
für die Zugriffsrechte festgelegt werden. 
Das isolierte undifferenzierte Modell bildet damit die Grundlage für die anderen g-SIS Modelle.

Im \emph{verbundenen undifferenzierten Modell} (im Folgenden g-SIS$^c$) kann die Mitgliedschaft in einer Gruppe 
verschiedene Auswirkungen auf andere Gruppen haben, die im folgenden Abschnitt genauer betrachtet werden.
Des weiteren haben die Mitglieder untereinander, wie im isolierten undifferenzierten Modell, die selben Zugriffsrechte.
In Abbildung \ref{img_models} sind die Beziehungen zwischen den einzelnen 
g-SIS Modellen grafisch dargestellt. Das isoliert undifferenzierte Modell ist in allen anderen Modellen enthalten.
Das isoliert differenzierte Modell und das verbunden undifferenzierte Modell sind in diesem Sinne nicht vergleichbar.
Das verbunden differenzierte Modell wiederum enthält alle anderen Modelle. 

Analog dazu lassen sich das verbunden differenzierte Modell und das isoliert differenzierte Modell beschreiben.
Im Folgenden soll allerdings lediglich das verbunden undifferenzierte Modell betrachtet werden, 
da dies ausreicht, um Aussagen über die Relationen zwischen Gruppen zu machen. 

\begin{figure}[htb] 
\centerline{\includegraphics*[width=0.8\textwidth]{gsis_modelle}}
\caption{Klassifikation der verschiedenen g-SIS Modelle} 
\label{img_models}
\end{figure}

\subsection{Relationen zwischen Gruppen}
Im verbunden undifferenzierten g-SIS Modell werden verschiedene Relationen für die Verbindungen zwischen einzelnen Gruppen vorgeschlagen.
Die betrachteten Entitäten sind wiederum Benutzer, denen ein gewisses Vertrauen entgegengebracht wird, sowie Subjekte und Objekte.
Subjekte, wie zum Beispiel Prozesse, die von einem Benutzer erstellt werden, müssen nicht notwendig die selben Rechte besitzen wie der Benutzer, der sie erstellt hat.
Da ein Subjekt potentiell schädlichen Code ausführen könnte, beispielsweise im Falle eines Virus, ist es sinnvoll Subjekte mit beschränkten Privilegien erstellen zu können.

Die folgenden Relationen zwischen Gruppen wurden vorgeschlagen:

\begin{figure}[htb] 
\centerline{\includegraphics*[width=0.8\textwidth]{rel_beispiel}}
\caption{Ein Beispiel für die möglichen Relationen zwischen Gruppen}
\label{img_rel}
\end{figure}

\begin{enumerate}
\item Conditional Membership (condM): Diese Relation definiert, dass die Mitgliedschaft eines Benutzers in 
einer Gruppe abhängig von seiner Mitgliedschaft in einer anderen Gruppe ist. Diese Relation ist als reflexiv, aber nicht als transitiv oder symmetrisch definiert 
und macht lediglich Aussagen über Gruppen für Benutzer, nicht für Subjekte. Ist Transitivität oder Symmetrie gewünscht, so muss dies explizit definiert werden.
In der Konfiguration aus Abbildung \ref{img_rel} wird zum Beispiel durch die Definition von condM(Meeting, \{Manager, Experten 1, Experten 2\}) verlangt, 
dass ein Benutzer nur Mitglied in der Meeting-Gruppe sein kann, wenn er Mitglied in einer der Gruppen Manager, Experten 1 oder Experten 2 ist.

\item Subordination: Diese Relationen definieren die Dominanz einer Gruppe über eine andere in verschiedenen Aspekten. 
Wie die Conditional Membership ist auch diese Relation lediglich als reflexiv definiert , aber nicht als transitiv oder symmetrisch.
\begin{itemize}
\item Create Subordination (subordC): Benutzer aus der dominierenden Gruppe können Subjekte in der dominierten Gruppe erstellen. 
Die Definition der Relation subordC(Meeting, Beschlüsse) erlaubt das Erstellen von Subjekten in der Gruppe Beschlüsse durch Benutzer aus Meeting.
\item Read Subordination (subordR): Subjekte aus der dominierenden Gruppe können Objekte in der dominierten Gruppe lesen. 
Durch subordR(Meeting, Beschlüsse) können Subjekte in Meeting auf Objekte in Beschlüsse lesend zugreifen.
\item Write Subordination (subordW): Subjekte aus der dominierenden Gruppe können auf Objekte in der dominierten Gruppe schreibend zugreifen.
Aufgrund von subordW(Manager, Meeting) kann ein Subjekt in der Manager Gruppe auf Objekte in der Meeting Gruppe schreibend zugreifen.
\item Move Subordination (subordM): Subjekte können von der dominierenden Gruppe in die dominierte Gruppe verschoben werden.
Mit subordM(Experten 1, Meeting) kann ein Subjekt aus Experten 1 in die Meeting Gruppe verschoben werden, kann dadurch aber den Zugriff auf Objekte aus der Experten 1 Gruppe verlieren.
\end{itemize}

\item Mutual Exclusion: Zwei Gruppen können als sich gegenseitig ausschließend definiert werden. 
Das führt dazu, dass Benutzer oder Objekte nicht zur gleichen Zeit Mitglied in beiden Gruppen sein dürfen.
Es ist jedoch möglich dieses Kriterium als dynamisch zu definieren, wodurch es möglich wird, dass ein Benutzer zwar Mitglied in beiden Gruppen ist, 
jedoch nicht in beiden Gruppen zur selben Zeit Subjekte erstellen kann.

\item Kardinalität: Eine Vielzahl an Beschränkungen der Kardinalität, wie zum Beispiel eine Kardinalität für die Anzahl der Benutzer, 
Subjekte oder Objekte in einer Gruppe, können definiert werden.
\end{enumerate}

In Abbildung \ref{img_rel} ist eine Beispielkonfiguration von g-SIS$^c$ zu sehen. Die Relationen innerhalb eines Systems können sich in g-SIS$^c$ auch mit der Zeit ändern, 
wenn sich die Anforderungen an das System ändern. Dies ist ein wichtiger Aspekt von g-SIS$^c$, 
da das Teilen von Informationen in einem System von den momentanen Bedürfnissen der Benutzer abhängt.

\section{Andere Zugriffskontrollmodelle in g-SIS$^c$}
\label{other_policies}
Mit Hilfe der beschriebenen Eigenschaften der g-SIS Modelle ist es nun möglich, bekannte Zugriffskontrollmodelle mit g-SIS zu modellieren.
Wie weiter oben schon erwähnt, reicht es hier und im Folgenden aus, das verbunden undifferenzierte Modell für diese Untersuchung zu betrachten.

\subsection{Lattice-Based Access Control in g-SIS$^c$}
In g-SIS$^c$ können LBAC Richtlinien, wie zum Beispiel das Bell-LaPadula Modell, modelliert werden. 
Um ein bestehendes Bell-LaPadula System in g-SIS$^c$ zu konstruieren, muss für jede Sicherheitsklasse in LBAC eine Gruppe in g-SIS$^c$ erstellt werden.
Für jede Sicherheitsklasse H, die eine Sicherheitsklasse L im Sinne von LBAC dominiert, müssen für die zugehörigen Gruppen G\_H und G\_L die Relationen subordR(G\_L, G\_H), 
subordC(G\_L, G\_H) und subordW(G\_H, G\_L) festgelegt werden. Da die Relationen in LBAC jedoch transitiv sind, muss darauf geachtet werden, 
diesen Schritt auch mit jeder Sicherheitsklasse zu wiederholen, die L dominiert. Für ein Beispiel dieser Transformation sei hier auf Sandhu et al. \cite{gsis2} verwiesen.

Für den Fall, dass zwei Organisationen mit unterschiedlichen LBAC Lattices Informationen austauschen wollen, kann dies im 
klassischen LBAC nicht durch einfache Anpassungen an den Lattices bewerkstelligt werden. Wurden die Richtlinien jedoch mit g-SIS$^c$ modelliert, 
ist es beispielsweise möglich alle Objekte mit Sicherheitsklasse L in Organisation A für alle Benutzer in Organisation B mit Sicherheitsklasse TS freizugeben.
Dazu muss lediglich die Relation subordR(G\_B\_TS, G\_A\_L) definiert werden.

\subsection{Domain and Type Enforcement in g-SIS$^c$}
Wie in Abschnitt \ref{dte} beschrieben, ist es mit klassischen LBAC Richtlinien nicht möglich bestimmte Anforderungen an den Informationsfluss innerhalb eines Systems zu erfüllen.
Dieses Problem kann mit DTE gelöst werden und DTE wiederum kann in g-SIS$^c$ modelliert werden.
Um eine vorhandene DTE Konfiguration in g-SIS$^c$ zu überführen werden zunächst Gruppen für alle in DTE vorhandenen Typen erstellt, in denen sich die Objekte befinden.
Für jede Domäne werden dann jeweils eine Gruppe für Benutzer und eine für Subjekte dieser Domäne erstellt. 
Die Benutzer besitzen die Mitgliedschaft in der Gruppe, die ihrer Domäne in DTE entspricht.

Für jede Domänengruppe mit Benutzern muss eine subordC Relation zur zugehörigen Gruppe der Subjekte dieser Domäne definiert werden.
Damit ist es für Benutzer aus einer Domäne möglich, Subjekte in der entsprechenden Domäne zu erstellen. 
Die Relationen zwischen den Gruppen der Subjekte und den Gruppen der Objekte werden dann entsprechend der DTE Matrix definiert.
Damit haben die Subjekte Zugriff auf die Objekte, auf die sie nach der DTE Matrix zugreifen dürfen.


\subsection{Role-Based Access Control in g-SIS$^c$}
Außer LBAC und DTE kann auch Core RBAC in g-SIS$^c$ modelliert werden. Jedoch ist das Ziel von g-SIS$^c$ das Teilen von Informationen mit einem Fokus auf die Lese- und Schreibrechte eines Objekts.
Da RBAC jedoch auch abstraktere Zugriffsrechte ermöglicht, ist es nicht sinnvoll dies direkt in g-SIS$^c$ zu modellieren. 
Daher sollen in dieser Betrachtung die Zugriffsrechte von Objekten auf Lese- und Schreibrechte beschränkt sein.
Es sei ein RBAC Modell mit den Rollen Manager und Experte gegeben. Die Rolle Manager hat Read und Write Zugriffsrechte auf das Objekt Bericht 1 und die 
Rolle Experte hat Read und Write Zugriffsrechte auf das Objekt Bericht 2.
Dieses Modell ist in Abbildung \ref{img_rbac1} veranschaulicht.

\begin{figure}[htb] 
\centerline{\includegraphics*[width=0.8\textwidth]{rbac_modell}}
\caption{Ein Beispiel RBAC$_0$ Modell mit Lese- und Schreibrechten auf zwei Objekte} 
\label{img_rbac1}
\end{figure}

Soll dieses Modell nun in g-SIS konfiguriert werden, so muss zunächst für jede Rolle eine eigene Gruppe erstellt werden.
Diese Gruppen repräsentieren die Zuordnung der Benutzer zu ihren Rollen. Jeder Benutzer darf jedoch nur in einer dieser Gruppen Mitglied sein.
Da es in RBAC jedoch möglich ist, mehr als einer Rolle zuzugehören, müssen alle Kombinationen der Rollen ebenfalls als eigene Gruppen angelegt werden.
In Abbildung \ref{img_rbac2} ist die resultierende g-SIS Konfiguration des RBAC$_0$ Modells dargestellt.
Im Beispiel resultieren aus diesem Schritt die Gruppen Manager\_G, Experte\_G und als Kombination ManagerExperte\_G.

\begin{figure}[htb] 
\centerline{\includegraphics*[width=0.8\textwidth]{rbac_gsis}}
\caption{Die äquivalente g-SIS Konfiguration des RBAC$_0$ Modells} 
\label{img_rbac2}
\end{figure}

Im nächsten Schritt müssen Gruppen für die möglichen Sessions angelegt werden. Dabei muss berücksichtigt werden, 
dass es möglich ist, dass eine Session keine aktivierten Rollen besitzt. Damit ergibt sich im Beispiel die Gruppe KeineRollen\_S, für eine Session ohne aktive Rollen.
Außerdem muss wiederum für jede mögliche Kombination von aktiven Rollen in einer Session eine Gruppe erstellt werden.
Das führt zu den Manager\_S und Experte\_S Gruppen, die Sessions darstellen, in denen die Manager oder die Experten Rolle aktiv ist, 
sowie die Gruppe ManagerExperte\_S für den Fall, dass beide Rollen aktiviert sind.

Benutzer müssen in der Lage sein Subjekte in diesen Gruppen zu erstellen. Daher sind subordC Relationen zwischen den Rollengruppen und den Sessiongruppen definiert.
Es muss außerdem in einer Session möglich sein, Rollen zu aktivieren oder zu deaktivieren. Dazu müssen symmetrische subordM Relationen zwischen allen Sessiongruppen definiert werden.
Das erlaubt den Subjekten die aktivierten Rollen zu ändern, indem sie in die entsprechende Sessiongruppe wechseln. 
Dies sollte jedoch nur möglich sein, wenn der Benutzer, der das Subjekt erstellt hat, auch den entsprechenden Rollen zugeordnet ist. 
Der Einfachheit halber soll hier jedoch auf diese notwendigen Bedingungen nicht weiter eingegangen werden.

Als letzter Schritt müssen nun noch Gruppen für die Objekte gebildet werden. Jedes Objekt benötigt eine Gruppe für jedes Zugriffsrecht. 
Daher ergeben sich die Gruppen Read\_Bericht1 und Write\_Bericht1, sowie Read\_Bericht2 und Write\_Bericht2.
Für jede Session werden dann entsprechend der Zugriffsrechte der aktiven Rollen die subordR und subordW Relationen zu den Objektgruppen definiert.
Die daraus resultierende g-SIS Konfiguration ist in Abbildung \ref{rbac_gsis} dargestellt.

\section{Fazit}
\label{summary}
Mit der Einführung von g-SIS wurde ein Konzept zur Zugriffskontrolle vorgeschlagen, dass für einige Anwendungsgebiete Vorteile bietet.
Wie gezeigt wurde, ist es möglich mit g-SIS verschiedene klassische Zugriffskontrollmodelle zu modellieren.
Außerdem ist es mit g-SIS möglich diese klassischen Modelle um Funktionen zu erweitern, die sonst nicht, oder nur mit einigem Aufwand möglich wären.
Dies zeigt, dass g-SIS ein sehr flexibles Modell ist, das in der Lage ist, sehr feingranular auf die Bedürfnisse der Benutzer einzugehen.
Außerdem ergibt sich durch die Berücksichtigung des zeitlichen Aspekts eine neue Art der Zugriffskontrolle, 
die in einigen Anwendungsgebieten Vorteile gegenüber den klassischen Modellen hat.

Jedoch ergeben sich durch die Möglichkeiten der feingranularen Anpassungsmöglichkeiten auch Schwierigkeiten.
Werden beispielsweise klassische Zugriffskontrollmodelle mit g-SIS modelliert, werden für vergleichsweise einfache Modelle, wie das RBAC Beispiel,
schnell sehr viele Gruppen benötigt. Das führt dazu, dass die Administration eines solchen Systems bei einer großen Anzahl von Benutzern und Gruppen 
sehr komplex werden kann. Durch den zeitlichen Aspekt wird dieses Problem noch verstärkt, da eventuell durch das Ausnutzen von Schwachstellen 
in der Konfiguration mit der Zeit Beschränkungen umgangen werden könnten.

Des weiteren ist uns kein System bekannt, das g-SIS in der Praxis einsetzt. Da lediglich die Policy Ebene untersucht wurde,
bleiben Dinge wie die konkrete Implementierung der Maßnahmen durch kryptographische Bausteine, das zugehörige Key Management oder Laufzeiten von Operationen unbeachtet.
Abschließend lässt sich sagen, dass g-SIS ein interessantes Konzept ist, das in bestimmten Bereichen und Anwendungsgebieten, 
wie zum Beispiel im System einer Onlinevideothek, anderen Systemen mit Digital Rights Management oder einem System für virtuelle Meetings, 
sinnvoll einsetzbar sein könnte. Es ist jedoch noch weitere Arbeit nötig, um das System zu formalisieren und praktisch anwendbar zu machen.

% \label{tmp_Subsection}
% Dies ist ein Unterabschnitt. Mit \LaTeX\ kann man auch prima Tabellen (siehe
% Beispieltabelle~\ref{tmp_tabelle}) erzeugen:
% \begin{table}[!htb] % das ! vor dem h heißt, dass LaTeX versucht, das "Gleitobjekt" 
                    % % wirklich hier zu plazieren
% \begin{center} % Zentrieren der Tabelle
% \begin{tabular}{|l||c|r|p{6.5cm}|}
% \hline
% \multicolumn{4}{|c|}{Beispieltabelle} \\
% \hline
% \hline
% Spalte 1       &    Spalte 2     &      Spalte 3     &        Spalte4 \\
% \hline
% linksbündig    & zentriert       & rechtsbündig      & 6.5cm breit, Fließtext
                                                       % ist möglich, d.h. der Text
                                                       % wird automatisch umgebrochen,
                                                       % allerdings im Blocksatz gesetzt.\\
% \hline
               % & \multicolumn{2}{c|}
                 % {Ein Eintrag über Spalte 2--3}      & Es gibt auch die Möglichkeit
                                                       % Flattersatz in Spalten einzusetzen.
                                                       % Das eignet sich besonders für kurze
                                                       % Spalten. Auch grau unterlegte 
                                                       % Tabellenzeilen oder Tabellen über
                                                       % mehrere Seiten sind möglich.\\
% \hline
% Man            &                 &                   &                          \\
% kann auch      & horizontale     & Linien            & einfach weglassen. \\
% \hline
% \end{tabular}
% \end{center}
% \caption{Beispiel einer Tabelle\label{tmp_tabelle}}
% \end{table}
%%
% Für Flattersatz in Tabellenspalten:
% \newcolumntype{z}{>{\PBS{\raggedright\hspace{0pt}}}p{5cm}}
% statt p{5cm} einfach z verwenden, z.B. \begin{tabular}{|l||c|r|z|}
% Für graue Tabellenspalten (z.B. zentrierter Text):
% \newcolumntype{g}{>{\columncolor[gray]{0.8}}c} % grau
% \newcolumntype{G}{>{\columncolor[gray]{0.9}}c} % helleres grau
% \begin{tabular}{|l||c|G|g|} oder auch \multicolumn{4}{|g|}{Eine ganze Zeile}
% Aber Achtung: Im xdvi werden graue Zeilen nicht korrekt dargestellt, erst
% im PostScript- oder PDF-Dokument bzw. Ghostview.
%
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
%
% --> Üblicherweise wird nur die Literatur aufgelistet, die auch referenziert
%     wird. Möchte man auch nichtreferenzierte Literatur einschließen, so
%     kann man dies mit \nocite{<citelabel>} tun.
%\nocite{*}
%     In die folgende Zeile sollte die benötigte Literaturdatenbankdatei
%     eingetragen werden (im Normalfall nicht zu ändern):

% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% Sollte noch zusätzliche Literatur verwendet worden sein, dann bitte die 
% folgende Zeile auskommentieren.
\bibliography{my_bibliography}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
%
\docend
%%% end of document
